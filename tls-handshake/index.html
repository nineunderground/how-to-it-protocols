<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TLS 1.3 Handshake ‚Äî How-To IT Protocols</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: #0a0e17;
            color: #e0e6ed;
            min-height: 100vh;
            padding: 30px 20px;
        }
        .back { color: #7b2ff7; text-decoration: none; font-size: 0.9rem; }
        .back:hover { text-decoration: underline; }
        h1 {
            text-align: center;
            font-size: 2rem;
            margin: 20px 0 8px;
            background: linear-gradient(135deg, #00d2ff, #7b2ff7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .desc {
            text-align: center;
            color: #8892a4;
            margin-bottom: 30px;
            font-size: 0.95rem;
            max-width: 650px;
            margin-left: auto;
            margin-right: auto;
        }

        .canvas-wrapper { max-width: 800px; margin: 0 auto; position: relative; }
        .diagram {
            position: relative;
            height: 580px;
            background: #101620;
            border: 1px solid #1e2a3a;
            border-radius: 12px;
            overflow: hidden;
        }

        .endpoint {
            position: absolute;
            top: 30px;
            width: 140px;
            text-align: center;
        }
        .endpoint.client { left: 60px; }
        .endpoint.server { right: 60px; }
        .endpoint .icon { font-size: 2.5rem; margin-bottom: 6px; }
        .endpoint .label { font-weight: 600; font-size: 1rem; }
        .endpoint .sublabel { font-size: 0.75rem; color: #8892a4; margin-top: 2px; }

        .timeline {
            position: absolute;
            top: 100px;
            bottom: 30px;
            width: 2px;
            background: #1e2a3a;
        }
        .timeline.client-line { left: 130px; }
        .timeline.server-line { right: 130px; }

        /* Encryption overlay */
        .encryption-zone {
            position: absolute;
            left: 0; right: 0;
            bottom: 0;
            height: 0;
            background: linear-gradient(180deg, rgba(0,230,118,0.03) 0%, rgba(0,230,118,0.08) 100%);
            border-top: 1px dashed rgba(0,230,118,0.3);
            transition: height 0.8s ease;
            pointer-events: none;
        }
        .encryption-label {
            position: absolute;
            top: 6px;
            right: 16px;
            font-size: 0.7rem;
            color: #4ade80;
            opacity: 0;
            transition: opacity 0.5s;
            font-weight: 600;
        }

        .packet {
            position: absolute;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.82rem;
            font-weight: 600;
            border-radius: 8px;
            opacity: 0;
            pointer-events: none;
            white-space: nowrap;
            padding: 0 14px;
        }
        .packet.client-hello {
            background: rgba(0, 210, 255, 0.15);
            border: 1px solid #00d2ff;
            color: #00d2ff;
        }
        .packet.server-hello {
            background: rgba(123, 47, 247, 0.15);
            border: 1px solid #7b2ff7;
            color: #a78bfa;
        }
        .packet.verify {
            background: rgba(251, 191, 36, 0.15);
            border: 1px solid #fbbf24;
            color: #fbbf24;
        }
        .packet.keys {
            background: rgba(236, 72, 153, 0.15);
            border: 1px solid #ec4899;
            color: #f472b6;
        }
        .packet.finished-c {
            background: rgba(0, 210, 255, 0.15);
            border: 1px solid #00d2ff;
            color: #00d2ff;
        }
        .packet.finished-s {
            background: rgba(123, 47, 247, 0.15);
            border: 1px solid #7b2ff7;
            color: #a78bfa;
        }
        .packet.app-data {
            background: rgba(0, 230, 118, 0.15);
            border: 1px solid #00e676;
            color: #00e676;
        }

        /* Center action (verify / derive) */
        .center-action {
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            padding: 6px 18px;
            border-radius: 8px;
            font-size: 0.82rem;
            font-weight: 600;
            opacity: 0;
            pointer-events: none;
            white-space: nowrap;
            text-align: center;
        }

        .state {
            position: absolute;
            font-size: 0.7rem;
            padding: 3px 10px;
            border-radius: 12px;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.4s;
        }
        .state.visible { opacity: 1; }
        .state.client-state { left: 60px; }
        .state.server-state { right: 60px; }
        .state.idle { background: #2d1f1f; color: #f87171; }
        .state.negotiating { background: #1f2535; color: #00d2ff; }
        .state.verifying { background: #2d2a1f; color: #fbbf24; }
        .state.deriving { background: #2d1f2d; color: #f472b6; }
        .state.finishing { background: #251f35; color: #a78bfa; }
        .state.encrypted { background: #1f2d1f; color: #00e676; }

        .step-info {
            max-width: 800px;
            margin: 20px auto 0;
            background: #141a26;
            border: 1px solid #1e2a3a;
            border-radius: 12px;
            padding: 24px;
            min-height: 120px;
        }
        .step-info h3 { font-size: 1.1rem; margin-bottom: 8px; }
        .step-info p { color: #8892a4; line-height: 1.6; font-size: 0.92rem; }
        .step-info .detail {
            margin-top: 12px;
            padding: 12px;
            background: #0a0e17;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.82rem;
            color: #a0aec0;
            white-space: pre-wrap;
        }

        .controls {
            max-width: 800px;
            margin: 20px auto 0;
            display: flex;
            gap: 12px;
            justify-content: center;
        }
        button {
            padding: 10px 28px;
            border: 1px solid #1e2a3a;
            border-radius: 8px;
            background: #141a26;
            color: #e0e6ed;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        button:hover { border-color: #7b2ff7; background: #1a2236; }
        button:disabled { opacity: 0.4; cursor: not-allowed; }
        button.primary { background: #7b2ff7; border-color: #7b2ff7; color: #fff; }
        button.primary:hover { background: #6b21e8; }

        .try-it { max-width: 800px; margin: 40px auto 0; }
        .try-it h2 { font-size: 1.5rem; margin-bottom: 8px; }
        .try-desc { color: #8892a4; margin-bottom: 20px; font-size: 0.92rem; }
        .terminal-tabs { display: flex; gap: 4px; margin-bottom: 0; }
        .tab {
            padding: 8px 20px;
            border: 1px solid #1e2a3a;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            background: #101620;
            color: #8892a4;
            cursor: pointer;
            font-size: 0.9rem;
        }
        .tab.active { background: #141a26; color: #e0e6ed; border-color: #1e2a3a; }
        .terminal-panel {
            background: #141a26;
            border: 1px solid #1e2a3a;
            border-radius: 0 12px 12px 12px;
            padding: 24px;
        }
        .terminal-panel.hidden { display: none; }
        .term-step { margin-bottom: 20px; }
        .term-step:last-child { margin-bottom: 0; }
        .term-badge {
            display: inline-block;
            padding: 3px 12px;
            border-radius: 12px;
            font-size: 0.78rem;
            font-weight: 600;
            margin-bottom: 8px;
        }
        .client-badge { background: #1f2535; color: #00d2ff; }
        .observe-badge { background: #2d2a1f; color: #fbbf24; }
        .term-block {
            background: #0a0e17;
            border-radius: 8px;
            padding: 16px;
            overflow-x: auto;
        }
        .term-header { font-size: 0.82rem; color: #8892a4; margin-bottom: 8px; }
        .term-block pre {
            margin: 0;
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            line-height: 1.6;
            color: #e0e6ed;
        }
        .term-block .prompt { color: #4ade80; }
        .term-block .comment { color: #4a5568; }
        .term-output {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #1e2a3a;
            font-family: 'Courier New', monospace;
            font-size: 0.82rem;
            color: #8892a4;
            white-space: pre-wrap;
        }
        .term-note {
            margin-top: 16px;
            padding: 12px 16px;
            background: rgba(123, 47, 247, 0.08);
            border-left: 3px solid #7b2ff7;
            border-radius: 0 8px 8px 0;
            font-size: 0.85rem;
            color: #a0aec0;
        }
        .term-note code {
            background: #0a0e17;
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.82rem;
        }

        /* Lock animation */
        .lock-icon {
            position: absolute;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            font-size: 3rem;
            opacity: 0;
            transition: opacity 0.6s, transform 0.6s;
            filter: drop-shadow(0 0 20px rgba(0,230,118,0.5));
            pointer-events: none;
        }
        .lock-icon.visible {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1.1);
        }

        /* Plaintext vs encrypted indicator */
        .channel-label {
            position: absolute;
            top: 96px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.72rem;
            padding: 3px 12px;
            border-radius: 12px;
            font-weight: 600;
            transition: all 0.5s;
        }
        .channel-label.plaintext { background: #2d1f1f; color: #f87171; }
        .channel-label.encrypted-ch { background: #1f2d1f; color: #4ade80; }
    </style>
</head>
<body>
    <a href="../" class="back">‚Üê Back to protocols</a>
    <h1>üîê TLS 1.3 Handshake</h1>
    <p class="desc">How a secure TLS 1.3 connection is established ‚Äî from plaintext ClientHello to fully encrypted application data, in just 1 round trip (1-RTT).</p>

    <div class="canvas-wrapper">
        <div class="diagram" id="diagram">
            <div class="endpoint client">
                <div class="icon">üíª</div>
                <div class="label">Client</div>
                <div class="sublabel">Browser</div>
            </div>
            <div class="endpoint server">
                <div class="icon">üñ•Ô∏è</div>
                <div class="label">Server</div>
                <div class="sublabel">example.com:443</div>
            </div>

            <div class="timeline client-line"></div>
            <div class="timeline server-line"></div>

            <div class="channel-label plaintext" id="channel-label">‚ö† PLAINTEXT</div>

            <div class="state idle client-state visible" id="client-state" style="top: 105px;">IDLE</div>
            <div class="state idle server-state visible" id="server-state" style="top: 105px;">WAITING</div>

            <!-- Packets -->
            <div class="packet client-hello" id="pkt-chello">ClientHello + KeyShare</div>
            <div class="packet server-hello" id="pkt-shello">ServerHello + KeyShare + Cert</div>
            <div class="packet verify" id="pkt-verify" style="font-size:0.8rem;">‚úì Verify Certificate</div>
            <div class="packet keys" id="pkt-keys" style="font-size:0.8rem;">üîë Derive Session Keys</div>
            <div class="packet finished-s" id="pkt-fin-s">Finished ‚úì</div>
            <div class="packet finished-c" id="pkt-fin-c">Finished ‚úì</div>
            <div class="packet app-data" id="pkt-app">üîí Encrypted Data</div>

            <!-- Center actions -->
            <div class="center-action verify" id="action-verify" style="background:rgba(251,191,36,0.12); border:1px solid #fbbf24; color:#fbbf24;">üîç Client verifies server certificate chain</div>
            <div class="center-action keys" id="action-keys" style="background:rgba(236,72,153,0.12); border:1px solid #ec4899; color:#f472b6;">üîë Both sides derive identical session keys (HKDF)</div>

            <div class="encryption-zone" id="enc-zone">
                <div class="encryption-label" id="enc-label">üîí ENCRYPTED CHANNEL</div>
            </div>

            <div class="lock-icon" id="lock-icon">üîí</div>
        </div>
    </div>

    <div class="step-info" id="step-info">
        <h3>Ready to start</h3>
        <p>Click <strong>Next Step</strong> to walk through the TLS 1.3 handshake. TLS 1.3 completes in just <strong>1 round trip</strong> (1-RTT), down from 2 in TLS 1.2.</p>
        <div class="detail">TLS 1.3 (RFC 8446) removes legacy crypto, mandates forward secrecy,
and encrypts more of the handshake compared to previous versions.</div>
    </div>

    <div class="controls">
        <button id="btn-reset" onclick="resetAnimation()">‚Ü∫ Reset</button>
        <button id="btn-next" class="primary" onclick="nextStep()">Next Step ‚Üí</button>
        <button id="btn-auto" onclick="autoPlay()">‚ñ∂ Auto Play</button>
    </div>

    <div class="try-it">
        <h2>üß™ Try It Yourself</h2>
        <p class="try-desc">Inspect a real TLS 1.3 handshake using common CLI tools.</p>

        <div class="terminal-tabs">
            <button class="tab active" onclick="switchTab('openssl')">openssl</button>
            <button class="tab" onclick="switchTab('curl')">curl</button>
            <button class="tab" onclick="switchTab('wireshark')">Wireshark</button>
        </div>

        <div class="terminal-panel" id="panel-openssl">
            <div class="term-step">
                <span class="term-badge client-badge">Connect & inspect handshake</span>
                <div class="term-block">
                    <div class="term-header">Full TLS 1.3 handshake with verbose output</div>
                    <pre><code><span class="prompt">$</span> openssl s_client -connect example.com:443 -tls1_3 -state -msg</code></pre>
                    <div class="term-output">CONNECTED(00000003)
SSL_connect:before SSL initialization
SSL_connect:SSLv3/TLS write client hello
SSL_connect:SSLv3/TLS read server hello
depth=2 C=US, O=DigiCert Inc, CN=DigiCert Global Root G2
verify return:1
SSL_connect:SSLv3/TLS read finished
SSL_connect:SSLv3/TLS write finished
---
New, TLSv1.3, Cipher is TLS_AES_256_GCM_SHA384
Server public key is 256 bit
SSL-Session:
    Protocol  : TLSv1.3
    Cipher    : TLS_AES_256_GCM_SHA384</div>
                </div>
            </div>
            <div class="term-step">
                <span class="term-badge observe-badge">Show certificate details</span>
                <div class="term-block">
                    <pre><code><span class="prompt">$</span> openssl s_client -connect example.com:443 -tls1_3 2>/dev/null | openssl x509 -noout -text | head -20</code></pre>
                </div>
            </div>
            <div class="term-note">
                üí° <strong>Tip:</strong> Use <code>-keylogfile keys.log</code> to export session keys for Wireshark decryption.
            </div>
        </div>

        <div class="terminal-panel hidden" id="panel-curl">
            <div class="term-step">
                <span class="term-badge client-badge">Verbose HTTPS request</span>
                <div class="term-block">
                    <div class="term-header">See TLS negotiation in curl output</div>
                    <pre><code><span class="prompt">$</span> curl -v --tls-max 1.3 https://example.com 2>&1 | head -30</code></pre>
                    <div class="term-output">* Connected to example.com (93.184.216.34) port 443
* ALPN: offers h2,http/1.1
* TLSv1.3 (OUT), TLS handshake, Client hello (1):
* TLSv1.3 (IN), TLS handshake, Server hello (2):
* TLSv1.3 (IN), TLS handshake, Encrypted Extensions (8):
* TLSv1.3 (IN), TLS handshake, Certificate (11):
* TLSv1.3 (IN), TLS handshake, CERT verify (15):
* TLSv1.3 (IN), TLS handshake, Finished (20):
* TLSv1.3 (OUT), TLS handshake, Finished (20):
* SSL connection using TLSv1.3 / TLS_AES_256_GCM_SHA384
* ALPN: server accepted h2</div>
                </div>
            </div>
            <div class="term-step">
                <span class="term-badge observe-badge">Check cipher suite only</span>
                <div class="term-block">
                    <pre><code><span class="prompt">$</span> curl -s -o /dev/null -w '%{ssl_version} %{ssl_cipher}\n' https://example.com</code></pre>
                    <div class="term-output">TLSv1.3 TLS_AES_256_GCM_SHA384</div>
                </div>
            </div>
            <div class="term-note">
                üí° <strong>Tip:</strong> Use <code>--tlsv1.3</code> to force TLS 1.3 only. Use <code>--cert-status</code> to request OCSP stapling.
            </div>
        </div>

        <div class="terminal-panel hidden" id="panel-wireshark">
            <div class="term-step">
                <span class="term-badge observe-badge">Capture TLS handshake packets</span>
                <div class="term-block">
                    <div class="term-header">Use tshark (CLI Wireshark) to see handshake messages</div>
                    <pre><code><span class="prompt">#</span> tshark -i eth0 -f "tcp port 443" -Y "tls.handshake" -O tls 2>/dev/null | head -50</code></pre>
                </div>
            </div>
            <div class="term-step">
                <span class="term-badge observe-badge">Filter TLS 1.3 ClientHello</span>
                <div class="term-block">
                    <pre><code><span class="prompt">#</span> tshark -i eth0 -f "tcp port 443" \
  -Y "tls.handshake.type == 1" \
  -T fields -e tls.handshake.ciphersuite</code></pre>
                    <div class="term-output">0x1301,0x1302,0x1303
<span class="comment"># 0x1301 = TLS_AES_128_GCM_SHA256
# 0x1302 = TLS_AES_256_GCM_SHA384
# 0x1303 = TLS_CHACHA20_POLY1305_SHA256</span></div>
                </div>
            </div>
            <div class="term-step">
                <span class="term-badge client-badge">Decrypt with SSLKEYLOGFILE</span>
                <div class="term-block">
                    <div class="term-header">Export session keys, then load in Wireshark</div>
                    <pre><code><span class="prompt">$</span> SSLKEYLOGFILE=~/keys.log curl https://example.com
<span class="comment"># In Wireshark: Edit ‚Üí Preferences ‚Üí TLS ‚Üí (Pre)-Master-Secret log ‚Üí ~/keys.log</span>
<span class="comment"># Now you can see decrypted application data!</span></code></pre>
                </div>
            </div>
            <div class="term-note">
                üí° <strong>Note:</strong> TLS 1.3 encrypts the Certificate message, so without key logging you'll only see ClientHello and ServerHello in plaintext.
            </div>
        </div>
    </div>

    <script>
        const clientLine = 131;
        function getServerLineX() { return diagram.offsetWidth - 131; }
        const diagram = document.getElementById('diagram');

        const steps = [
            {
                id: 0,
                title: "Initial State",
                desc: "The TCP connection is already established (see <a href='../tcp-handshake/' style='color:#7b2ff7'>TCP handshake</a>). Now the client will initiate TLS 1.3 to secure the channel. Everything starts in <strong>plaintext</strong>.",
                detail: "Protocol: TLS 1.3 (RFC 8446)\nTransport: TCP (already connected)\nChannel: PLAINTEXT ‚Äî anyone on the wire can read traffic\n\nTLS 1.3 improvements over 1.2:\n  ‚Ä¢ 1-RTT handshake (was 2-RTT)\n  ‚Ä¢ Mandatory forward secrecy (ECDHE)\n  ‚Ä¢ Encrypted certificate (server identity hidden)\n  ‚Ä¢ Removed RSA key exchange, RC4, SHA-1, CBC mode",
                clientState: { text: "IDLE", cls: "idle" },
                serverState: { text: "WAITING", cls: "idle" },
                channel: "plaintext"
            },
            {
                id: 1,
                title: "Step 1: ClientHello",
                desc: "The client sends <strong>ClientHello</strong> with supported cipher suites, a <strong>key_share</strong> extension (ECDHE public key), and supported TLS versions. This is sent in <strong>plaintext</strong>.",
                detail: "ClientHello:\n  Protocol Version: TLS 1.2 (for compatibility)\n  Supported Versions ext: TLS 1.3\n  Cipher Suites:\n    ‚Ä¢ TLS_AES_256_GCM_SHA384\n    ‚Ä¢ TLS_AES_128_GCM_SHA256\n    ‚Ä¢ TLS_CHACHA20_POLY1305_SHA256\n  Key Share:\n    ‚Ä¢ x25519: 04a1b2c3... (client ECDHE public key)\n  Signature Algorithms:\n    ‚Ä¢ ecdsa_secp256r1_sha256\n    ‚Ä¢ rsa_pss_rsae_sha256\n  SNI: example.com",
                packet: "pkt-chello", direction: "right", yPos: 140,
                clientState: { text: "WAIT_SH", cls: "negotiating" },
                serverState: { text: "WAITING", cls: "idle" },
                channel: "plaintext"
            },
            {
                id: 2,
                title: "Step 2: ServerHello + Certificate",
                desc: "The server responds with <strong>ServerHello</strong> (chosen cipher, its key_share), then sends <strong>EncryptedExtensions</strong>, <strong>Certificate</strong>, and <strong>CertificateVerify</strong> ‚Äî all encrypted with handshake keys.",
                detail: "ServerHello (plaintext):\n  Cipher Suite: TLS_AES_256_GCM_SHA384\n  Key Share:\n    ‚Ä¢ x25519: 05d4e5f6... (server ECDHE public key)\n\n{Encrypted with handshake keys}:\n  EncryptedExtensions: ALPN=h2\n  Certificate:\n    ‚Ä¢ example.com (leaf)\n    ‚Ä¢ DigiCert TLS RSA SHA256 (intermediate)\n  CertificateVerify:\n    ‚Ä¢ RSA-PSS signature over handshake transcript",
                packet: "pkt-shello", direction: "left", yPos: 210,
                clientState: { text: "WAIT_SH", cls: "negotiating" },
                serverState: { text: "WAIT_FIN", cls: "negotiating" },
                channel: "plaintext"
            },
            {
                id: 3,
                title: "Step 3: Client Verifies Certificate",
                desc: "The client validates the server's <strong>certificate chain</strong> against trusted CAs, checks the <strong>CertificateVerify</strong> signature, and confirms the server's identity matches the requested SNI.",
                detail: "Certificate Verification:\n  1. Check leaf cert subject/SAN matches \"example.com\"\n  2. Verify signature chain: leaf ‚Üí intermediate ‚Üí root CA\n  3. Check certificate not expired (notBefore/notAfter)\n  4. Check revocation (OCSP stapling / CRL)\n  5. Verify CertificateVerify signature over transcript\n  \n  Result: ‚úÖ Certificate valid, server identity confirmed",
                centerAction: "action-verify", actionY: 285,
                clientState: { text: "VERIFYING", cls: "verifying" },
                serverState: { text: "WAIT_FIN", cls: "negotiating" },
                channel: "plaintext"
            },
            {
                id: 4,
                title: "Step 4: Derive Session Keys",
                desc: "Both sides combine the ECDHE shared secret with the handshake transcript to derive identical <strong>session keys</strong> using <strong>HKDF</strong>. From here on, everything is encrypted.",
                detail: "Key Derivation (HKDF-Expand-Label):\n  ECDHE Shared Secret = X25519(client_priv, server_pub)\n  \n  Early Secret    ‚Üê HKDF-Extract(0, 0)\n  Handshake Secret ‚Üê HKDF-Extract(Early, ECDHE_shared)\n  Master Secret   ‚Üê HKDF-Extract(Handshake, 0)\n  \n  Derived keys:\n    ‚Ä¢ client_application_traffic_secret\n    ‚Ä¢ server_application_traffic_secret\n    ‚Ä¢ client_write_key + client_write_iv\n    ‚Ä¢ server_write_key + server_write_iv\n  \n  Cipher: AES-256-GCM with derived keys",
                centerAction: "action-keys", actionY: 340,
                clientState: { text: "KEYS DERIVED", cls: "deriving" },
                serverState: { text: "KEYS DERIVED", cls: "deriving" },
                channel: "plaintext",
                showEncryption: true
            },
            {
                id: 5,
                title: "Step 5: Finished Messages",
                desc: "Both sides exchange <strong>Finished</strong> messages containing a MAC over the entire handshake transcript. This proves neither side's messages were tampered with.",
                detail: "Server Finished (already sent with ServerHello flight):\n  verify_data = HMAC(server_handshake_traffic_secret,\n                     Hash(handshake_transcript))\n\nClient Finished:\n  verify_data = HMAC(client_handshake_traffic_secret,\n                     Hash(handshake_transcript))\n\n‚úÖ Both sides verified ‚Äî handshake integrity confirmed\n   Forward secrecy: ECDHE ephemeral keys discarded",
                packets: [
                    { id: "pkt-fin-s", direction: "left", yPos: 400 },
                    { id: "pkt-fin-c", direction: "right", yPos: 440 }
                ],
                clientState: { text: "CONNECTED", cls: "finishing" },
                serverState: { text: "CONNECTED", cls: "finishing" },
                channel: "encrypted"
            },
            {
                id: 6,
                title: "Step 6: Encrypted Application Data üîí",
                desc: "The handshake is complete! All application data is now <strong>encrypted with AES-256-GCM</strong>. The lock icon confirms a secure channel. HTTP requests, responses, cookies ‚Äî everything is protected.",
                detail: "üîí SECURE CHANNEL ESTABLISHED\n\n  Protocol:  TLS 1.3\n  Cipher:    TLS_AES_256_GCM_SHA384\n  Key Exch:  X25519 (ECDHE)\n  Auth:      RSA-PSS (2048-bit)\n  ALPN:      h2 (HTTP/2)\n  \n  Forward Secrecy: ‚úÖ (ephemeral ECDHE)\n  0-RTT:           Available for resumption\n  \n  GET / HTTP/2  ‚Üí  encrypted  ‚Üí  üîí  ‚Üí  decrypted  ‚Üí  200 OK",
                packet: "pkt-app", direction: "right", yPos: 495,
                clientState: { text: "üîí ENCRYPTED", cls: "encrypted" },
                serverState: { text: "üîí ENCRYPTED", cls: "encrypted" },
                channel: "encrypted",
                showLock: true
            }
        ];

        let currentStep = 0;
        let isAnimating = false;

        function animatePacket(packetId, direction, yPos) {
            return new Promise(resolve => {
                const pkt = document.getElementById(packetId);
                const serverX = getServerLineX();
                const pw = pkt.offsetWidth || 180;
                const startX = direction === 'right' ? clientLine + 10 : serverX - pw - 10;
                const endX = direction === 'right' ? serverX - pw - 10 : clientLine + 10;

                pkt.style.top = yPos + 'px';
                pkt.style.left = startX + 'px';
                pkt.style.opacity = '1';
                pkt.style.transition = 'left 1.2s ease-in-out';

                requestAnimationFrame(() => requestAnimationFrame(() => {
                    pkt.style.left = endX + 'px';
                }));
                setTimeout(resolve, 1300);
            });
        }

        function showCenterAction(actionId, yPos) {
            return new Promise(resolve => {
                const el = document.getElementById(actionId);
                el.style.top = yPos + 'px';
                el.style.opacity = '0';
                el.style.transition = 'opacity 0.6s';
                requestAnimationFrame(() => { el.style.opacity = '1'; });
                setTimeout(resolve, 800);
            });
        }

        function updateStates(step) {
            const cs = document.getElementById('client-state');
            const ss = document.getElementById('server-state');
            cs.textContent = step.clientState.text;
            cs.className = `state client-state visible ${step.clientState.cls}`;
            ss.textContent = step.serverState.text;
            ss.className = `state server-state visible ${step.serverState.cls}`;

            const ch = document.getElementById('channel-label');
            if (step.channel === 'encrypted') {
                ch.textContent = 'üîí ENCRYPTED';
                ch.className = 'channel-label encrypted-ch';
            } else {
                ch.textContent = '‚ö† PLAINTEXT';
                ch.className = 'channel-label plaintext';
            }
        }

        function updateInfo(step) {
            document.getElementById('step-info').innerHTML = `
                <h3>${step.title}</h3>
                <p>${step.desc}</p>
                <div class="detail">${step.detail}</div>
            `;
        }

        async function nextStep() {
            if (isAnimating || currentStep >= steps.length) return;
            isAnimating = true;
            document.getElementById('btn-next').disabled = true;
            document.getElementById('btn-auto').disabled = true;

            const step = steps[currentStep];
            updateInfo(step);
            updateStates(step);

            if (step.showEncryption) {
                const zone = document.getElementById('enc-zone');
                zone.style.height = '200px';
                document.getElementById('enc-label').style.opacity = '1';
            }

            if (step.packet) {
                await animatePacket(step.packet, step.direction, step.yPos);
            }
            if (step.packets) {
                for (const p of step.packets) {
                    await animatePacket(p.id, p.direction, p.yPos);
                }
            }
            if (step.centerAction) {
                await showCenterAction(step.centerAction, step.actionY);
            }
            if (step.showLock) {
                document.getElementById('lock-icon').classList.add('visible');
                await new Promise(r => setTimeout(r, 600));
            }

            currentStep++;
            isAnimating = false;
            document.getElementById('btn-next').disabled = currentStep >= steps.length;
            document.getElementById('btn-auto').disabled = currentStep >= steps.length;
        }

        async function autoPlay() {
            while (currentStep < steps.length) {
                await nextStep();
                if (currentStep < steps.length) await new Promise(r => setTimeout(r, 1000));
            }
        }

        function resetAnimation() {
            currentStep = 0;
            isAnimating = false;

            ['pkt-chello','pkt-shello','pkt-verify','pkt-keys','pkt-fin-s','pkt-fin-c','pkt-app'].forEach(id => {
                const el = document.getElementById(id);
                el.style.transition = 'none';
                el.style.opacity = '0';
            });
            ['action-verify','action-keys'].forEach(id => {
                document.getElementById(id).style.opacity = '0';
            });

            document.getElementById('enc-zone').style.height = '0';
            document.getElementById('enc-label').style.opacity = '0';
            document.getElementById('lock-icon').classList.remove('visible');

            updateStates(steps[0]);
            updateInfo(steps[0]);
            document.getElementById('btn-next').disabled = false;
            document.getElementById('btn-auto').disabled = false;
        }

        function switchTab(name) {
            document.querySelectorAll('.terminal-panel').forEach(p => p.classList.add('hidden'));
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.getElementById('panel-' + name).classList.remove('hidden');
            event.target.classList.add('active');
        }

        updateStates(steps[0]);
    </script>
</body>
</html>
